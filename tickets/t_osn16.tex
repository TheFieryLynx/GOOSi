\textbf{\LARGE osn 16.Формализация понятия алгоритма. Машины Тьюринга, нормальные алгоритмы Маркова. Алгоритмическая неразрешимость. Задача останова. Задача самоприменимости.}


\textbf{Интуитивное понятие алгоритма} --- четкая система действий, позволяющая определенным образом обработать входные данные и выдать результат решения задачи. Важен исполнитель алгоритма. Одна и та же система действий для одного исполнителя будет алгоритмом, а для другого --- нет.

Алгоритм \textbf{применим} к входным данным, если исполнитель за конечное число шагов остановится и выдаст (какой-то) ответ. В противном случае алгоритм \textbf{неприменим} к конкретным входным данным, т.е. он не остановится, либо завершит своё выполнение аварийно (сломается).

\textbf{Основные свойства алгоритма:}
\begin{enumerate}
    \item\textit{Определенность (понятность)}. Исполнитель алгоритма абсолютно точно знает, как выполнять все шаги алгоритма.
    \item \textit{Детерминированность}. Если алгоритм применим к конкретным входным данным, то он всегда и везде выдаст одинаковый ответ, а если неприменим, то всегда и везде зациклится или сломается.
    \item \textit{Дискретность или структурность.} Каждый достаточно сложный шаг алгоритма тоже является алгоритмом и может быть разложен на более простые шаги. Это же касается и обрабатываемых алгоритмом данных.
\end{enumerate}

Существуют разные способы формализации понятия алгоритма, \faEye \ два из них: машины Тьюринга и нормальные алгоритмы Маркова.


\textbf{Машина Тьюринга} --- гипотетическая машина (из-за использования бесконечной ленты). Автомат может двигаться вдоль ленты и по очереди обозревать содержимое ячеек. Он может находиться в одном из нескольких состояний $q_1,\dots, q_k$. В зависимости от того, какую букву $s_i$ автомат видит в состоянии $q_j$, то есть от пары $(s_i,q_j)$ (i --- номер ячейки, j --- номер состояния) автомат может выполнить следующие действия:
\begin{itemize}
    \item[--] запись новой буквы в обозреваемую ячейку; 
    \item[--] сдвиг влево или вправо на одну ячейку;
    \item[--] переход в новое состояние.
\end{itemize}


\textbf{Пример:} перенести первый символ непустого слова Р в его конец.
\begin{center}
\begin{tabular}{ |c||c|c|c|c||c| } 
\hline
       & a                   & b                   & c                  & $\Lambda$ & комментарий \\ 
\hline
\hline
 $q_1$ & $ \lambda, R, q_2 $ & $ \lambda, R, q_3 $ & $\lambda, R, q_4 $ & $, R,$    & анализ I симв., удаление \\ 
\hline
 $q_2$ & $, R,$              & $, R,$              & $, R,$             & $a, ,!$   & запись $a$ справа \\
\hline
 $q_3$ & $, R,$              & $, R,$              & $, R,$             & $b, ,!$   & запись $b$ справа \\
\hline
$q_4$  & $, R,$              & $, R,$              & $, R,$             & $c, ,!$   & запись $c$ справа \\
\hline
\end{tabular}
\end{center}

\textbf{Тезис Тьюринга:} если кто-то предложит какой-либо алгоритм обработки слов в заданном алфавите, то можно построить эквивалентную машину Тьюринга, которая будет применима и неприменима к одинаковым множествам слов.
В случае машины Тьюринга \textbf{алгоритм} --- это то, что может быть реализовано МТ.


\textbf{Нормальный алгоритм Маркова:}
        
Нет понятия ленты и подразумевается непосредственный доступ к любым частям преобразуемого слова. Пусть $A, B$ -- слова в некотором алфавите. Нормальный алгоритм можно записать в следующем виде: $A_i \left\{\begin{array}{lr} \to \\ \mapsto \end{array}\right\} B_i$.
Каждая пара -- формула подстановки для замены подслов в преобразуемом слове. Ищется вхождение слова $A_1$ в исходное слово. Если нашли, то заменяем его на $B_1$, если нет, то ищем $A_2$ и так далее. Затем возвращаемся в начало и снова ищем вхождение $A_1$. Процесс заканчивается, если ни одна из подстановок не применима, либо применилась завершающая формула, в которой $\mapsto$.

\textbf{Пример:} $A = \{a, b\}$. Преобразовать слово $P$ так, чтобы в его начале оказались все символы $a$, а в конце -- все символы $b$.

$$\begin{cases}
     ba \to ab &\\
\end{cases}$$

\textbf{Тезис Маркова:} если кто-то предложит какой-либо алгоритм обработки слов в заданном алфавите, то его можно нормализовать, т.е. построить эквивалентный нормальный алгоритм Маркова, который будет применим и неприменим к одинаковым множествам слов.
Машина Тьюринга и нормальные алгоритмы Маркова эквивалентны.

\centerline{\textbf{Самоприменимость}}

Входное слово, которое подаётся на вход алгоритму, может быть записью какого-то другого алгоритма. Когда алгоритм применим к своей записи, он называется \textbf{самоприменимым}.

\textbf{Теорема.} Если есть два алгоритма таких, что выходные данные одного можно использовать как входные данные для другого, то обязательно существует третий алгоритм, который работает как суперпозиция (композиция, последовательное выполнение) двух первых алгоритмов. [Давалась без док-ва]


\centerline{\textbf{Задача останова}} 

Пусть требуется построить алгоритм $X$, который, получая на входе запись любого алгоритма $A$ и его конкретные входные данные $D$, определяет, применим ли $A$ к этим данным $D$ (остановится ли $A$, получив на входе $D$).
    
\textbf{Теорема}. Такого алгоритма $X$ не существует. [Давалась без док-ва]
    
\centerline{\textbf{Алгоритмическая неразрешимость}}
Существуют задачи, для которых в принципе невозможно построить алгоритм их решения, они и называются \textbf{алгоритмически неразрешимыми}. Пусть требуется построить алгоритм $X$, который, получая на вход запись любого алгоритма $A$, определяет, самоприменим ли этот $A$, или нет. 
    
\textbf{Теорема.} Алгоритм $X$ не существует.

\begin{proof} Доказательство от противного. Пусть алгоритм $X$ существует, и, получив на вход запись алгоритма $A$, он вырабатывает ответ $DA$ (Да), если $A$ самоприменим, и ответ $NET$ (Нет), если несамоприменим.
Построим вспомогательный алгоритм $Y$ , вот его запись в форме НАМ:
$$\begin{cases} DA \to DA \\ NET \mapsto NET\end{cases}$$

Как видно, мы специально сделали так, чтобы выходные данные алгоритма $X$ можно подать на вход алгоритма $Y$. Тогда обязательно существует алгоритм $Z$, который работает как суперпозиция $X * Y$, то есть $Z = X * Y$. \faEye, самоприменим ли Z.
\begin{itemize}
    \item[--] Пусть $Z$ самоприменим, тогда $\langle \text{запись } Z\rangle Z \to \langle \text{запись } Z \rangle X * Y \to \langle DA \rangle Y \to $ Зациклились, предположение неверно.
    \item[--] Пусть Z несамоприменим, тогда $\langle \text{запись } Z \rangle Z \to \langle \text{запись } Z \rangle X * Y \to \langle NET \rangle Y \to $ Стоп, алгоритм самоприменим, предположение неверно.
\end{itemize} 
Как видно, оба предположения неверны, поэтому делаем вывод, что алгоритм $Z$ не существует. Однако алгоритм $Y$ существует (мы его построили), поэтому не существует алгоритм $X$. 
\end{proof}
    




% -------- source --------
\bigbreak
[\cite{pilschikov}]