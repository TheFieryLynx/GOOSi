\textbf{\LARGE osn 22. Виды параллельной обработки данных, их особенности. Компьютеры с общей и распределенной памятью. Производительность вычислительных систем, методы оценки и измерения.}


Параллельная обработка данных имеет две разновидности: конвейерность и параллельность.
\begin{itemize}
    \item \textbf{Параллельная обработка.} Увеличение количества независимо работающих устройств. Если некое устройство выполняет одну операцию за единицу времени, то тысячу операций оно выполнит за тысячу единиц. Система из N устройств ту же работу выполнит за 1000/N единиц времени (в идеальном случае).
    \item \textbf{Конвейерная обработка.} Усложнение самого устройства, чтобы на разных этапах могли находиться разные данные. Идея заключается в выделении отдельных этапов выполнения общей операции, причем каждый этап, выполнив свою работу, передавал бы результат следующему, одновременно принимая новую порцию входных данных. Получаем выигрыш в скорости обработки за счет совмещения прежде разнесенных во времени операций. Существует некоторая задержка (время разгона), для того, чтобы заполнить все этапы конвейера; когда он заполнен, происходит ускорение обработки.
\end{itemize}

\textbf{Классификация многопроцессорных сетей по Флинну.}

В контексте машины можно выделить два потока информации: \textbf{поток управления} (для передачи управляющих воздействий на конкретное устройство) и \textbf{поток данных} (циркулирующий между оперативной памятью и внешними устройствами). В связи с этим выделяют 4 основных класса: SISD (1 поток команд, 1 поток данных. ``Традиционный'' последовательный компьютер), SIMD (1 поток команд, много потоков данных, пример - векторные компьютеры), MISD (много п. ком., 1 п. данных), MIMD (много и потоков команд, и данных). Среди MIMD можно выделить системы с общей ОП и системы с распределенной памятью.

\begin{itemize}
    \item \textbf{Компьютеры с общей памятью.}
    
    В системе присутствует несколько равноправных процессоров, имеющих одинаковый доступ к единой памяти. Всё, кроме процессоров, в одном экземпляре: образ операционной системы, память, подсистема ввода-вывода и т.д. Все процессоры работают с единым адресным пространством. (+) относительная простота параллельного программирования; (–) сложность увеличения числа процессоров (роста производительности).
    
    \textbf{UMA} -- системы с однородным доступом к памяти (все процессоры имеют одинаковый доступ к памяти). SMP --- есть общая шина, соединенная со всеми процессорами и с ОП.
    
    \textbf{NUMA} (Non Uniform Memory Access) -- память физически распределена, но логически общедоступна. Каждый вычислительный узел компьютера содержит процессор, локальную память, контроллер памяти и, быть может, некоторые устройства ввода/вывода. Контроллер памяти определяет, является ли запрос к памяти локальным или его необходимо передать удаленному узлу через коммутатор/шину. Проблема -- синхронизация кэш. 
    
    \textbf{ccNUMA} (cache coherent NUMA). На аппаратном уровне решает проблему когерентности кэшей. Но остаются ограничения, связанные с централизацией -- использованием системной шины, возникают ограничения, связанные с cc-архитектурой: есть системные потоки служебной информации, что ведет к дополнительным накладным расходам --- загрузке общей шины служебной информацией
    
    \item \textbf{Компьютеры с распределенной памятью.}
    
    Состоят из вычислительных узлов, каждый из которых является полноценным компьютером со своей памятью, ОС, устройствами ввода-вывода и т.п., взаимодействующих друг с другом через коммуникационную среду.
    (–) сложность параллельного программирования;
    (+) относительная простота увеличения числа процессоров (роста производительности).
\end{itemize}

\textbf{Основные понятия для распределённых систем}
\begin{itemize}
    \item \textbf{Длина критического пути} -- минимальное количество элементарных связей, которые нужно пройти для коммутации двух самых удаленных процессоров. \todo{что такое коммутация процессов?}
    \item \textbf{Связность} -- минимальное количество элементарных связей, которые нужно удалить, чтобы схема распалась на две несвязанные части.
    \item \textbf{Сложность} --- общее количество необходимых элементарных связей. 
    \item \textbf{Латентность и пропускная способность сети} – основные параметры коммуникационной сети кластеров. 
    
    \textbf{Латентность} --- время начальной задержки при посылке сообщений. 
    
    \textbf{Пропускная способность сети} определяется скоростью передачи информации по каналам связи и измеряется объёмом передаваемой информации в единицу времени. Время на передачу сообщения по коммуникационной сети вычисляется по следующей формуле: $t_N = t_0 + \frac{N}{S}$ , где $t_0$ -- латентность, $N$ -- объём передаваемых данных, $S$ -- пропускная способность сети.
\end{itemize}

\resizebox{\columnwidth}{!}{
\begin{tabular}{ |c|c|c|c| } 
    \hline
    Схема коммутации & Длина критического пути & Связность & Сложность \\ 
    \hline\hline
    линейка & $p - 1$  & $1$ & $p - 1$ \\ 
    \hline
    кольцо & $|\frac{p}{2}|$ & $2$ & $p$ \\
    \hline
    звезда & $2$ & $1$ & $p - 1$ \\
    \hline 
    полносвязная топология & $1$ & $p - 1$ & $ \frac{p(p-1)}{2}$\\
    \hline
\end{tabular}
}
\begin{center}
    $p$ -- количество процессов
\end{center}

\textbf{Методы оценки производительности.}
\begin{itemize}
    \item \textbf{Пиковая производительность} -- теоретический предел производительности для данного компьютера. Пиковая производительность компьютера вычисляется как сумма пиковых производительностей всех входящих в него вычислительных устройств (процессоров, ускорителей и т.д.). Даёт нижнюю оценку времени выполнения программы. Производительность компьютера на любой реальной программе никогда не только не превысит этого порога, но и не достигнет его точно.
    \item \textbf{Реальная производительность} -- производительность данного компьютера на конкретном приложении. Традиционно используются два способа оценки производительности компьютера. Один из них опирается на число команд, выполняемых компьютером в единицу времени. Единица измерения -- \textbf{MIPS} (Million Instructions Per Second). Второй способ -- число вещественных операций, выполняемых компьютером в единицу времени -- \textbf{Flops} (Floating point operations per second).
    
    Популярные тесты: 
    \item[--] \textbf{LINPACK}: измерение производительности при обработке чисел с плавающей точкой. Задача: решение СЛАУ.
    \item[--] \textbf{Graph500}: нагружает коммуникационную систему компьютера и не зависит от количества исполняемых в секунду операций с числами с плавающей точкой. Задача: поиск в ширину в большом ненаправленном графе.
    \item[--] \textbf{NAS Parallel Benchmark}: набор различных задач для проверки производительности.
\end{itemize}



% % -------- source --------
% \bigbreak
% [\cite[page 69-96]{replace_me}]