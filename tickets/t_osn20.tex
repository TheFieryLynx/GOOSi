\textbf{\LARGE osn 20. Основные принципы объектно-ориентированного программирования. Реализация этих принципов в языке С++. Примеры.}


\centerline{\textbf{Основные механизмы (постулаты) ООП:}}

1. \textbf{Инкапсуляция} -- это \textit{механизм}, который связывает данные с обрабатывающими их кодами и защищает и те, и другие от внешних воздействий и ошибочных действий. В объектно-ориентированном языке коды и данные могут быть связаны так, что вместе они создают автономный \textit{черный ящик}. Внутри этого ящика содержатся все необходимые данные и коды. При связывании таким образом данных и кодов создается \textit{объект}. Другими словами, объект представляет собой устройство, поддерживающее инкапсуляцию.
    
Внутри объекта коды или данные или и те, и другие могут иметь атрибут \textit{private}, что делает их закрытыми для внешнего мира, или \textit{public}, что открывает эти элементы объекта. Закрытые коды и данные известны и доступны только из других частей того же объекта. Другими словами, к закрытым кодам и данным нельзя обратиться ни из какого фрагмента программы, существующего вне объекта. Если же код или данные объявлены с атрибутом public, то доступ к ним открыт из любых частей программы, несмотря на то, что эти элементы определены внутри объекта. Обычно открытые элементы объекта используются для обеспечения контролируемого интерфейса с закрытыми элементами того же объекта.
    
В С++ базовой единицей инкапсуляции является \textbf{класс}. Класс определяет содержание объекта. Класс описывает как данные, так и коды, предназначенные для операций над этими данными. С++ использует спецификацию класса при конструировании \textit{объектов}. Объекты являются экземплярами класса. Т.е. класс в сущности представляет собой набор чертежей, по которым строится объект.
    
Код и данные, составляющие класс, называются \textit{членами} класса. Конкретно, \textit{члены-переменные}, называемые также переменными экземпляра, -- это данные, определенные в классе. \textit{Члены-функции}, или просто функции -- это коды, предназначенные для операций над данными.
    
2. \textbf{Полиморфизм} обозначает средство, позволяющее посредством единого интерфейса получить доступ к целому классу действий. Простым примером полиморфизма может служить рулевое колесо автомобиля. Рулевое колесо (интерфейс) остается одним и тем же, независимо от того, какой тип рулевого механизма используется в данном автомобиле. Другими словами, рулевое колесо действует одинаково для любых автомобилей: с непосредственным приводом на колеса, с гидравлическим усилителем или с реечной передачей. Поворот рулевого колеса влево заставляет автомобиль двигаться влево независимо от типа рулевого механизма. Достоинство единого интерфейса, очевидно, заключается в том, что если вы умеете пользоваться рулевым колесом, вы можете ездить на любых автомобилях.
    
Рассмотрим стек (список, действующий по правилу “первым вошел, последним вышел”). Пусть вашей программе требуется три стека различных видов. Один стек используется для целых чисел, другой для чисел с плавающей точкой, а третий для одиночных символов. Алгоритм реализации всех трех стеков будет одинаков, несмотря на то, что данные, заносимые в разные стеки, различаются. 
    
В общем случае концепция полиморфизма часто выражается фразой “один интерфейс, много методов”. Это означает возможность разработать обобщенный интерфейс для группы схожих действий.
    
Различают \textbf{статический} (реализуется на этапе компиляции с помощью перегрузки функций и операций), \textbf{динамический} (реализуется во время выполнения программы с помощью механизма виртуальных функций) и \textbf{параметрический} (реализуется на этапе компиляции с использованием механизма шаблонов) полиморфизм.
    
3. \textbf{Наследование} является процессом, который позволяет одному объекту приобретать свойства другого объекта. Важность наследования определяется тем, что оно поддерживает концепцию иерархической классификации. Большая часть наших знаний построена по иерархическому принципу. Например, антоновка является частью класса яблок, который, в свою очередь, есть часть класса фруктов; фрукты же входят в более широкий класс пищевых продуктов. Класс пищевые продукты обладает определенными качествами (съедобность, пищевая ценность и т. д.), которые, логично предположить, приложимы и к его подклассу фрукты. В дополнение к этим качествам класс фрукты обладает специфическими характеристиками (сочность, сладость и др.), которые выделяют его среди других пищевых продуктов. Класс яблоки определяет качества, характерные для яблок (растут на деревьях, не являются тропическими продуктами и т. д.). Класс антоновка, в свою очередь, наследует все качества всех предшествующих классов и определяет лишь те качества, которые выделяют антоновку среди прочих яблок.
    
Если не пользоваться иерархией, то каждый объект должен был бы явно определять все свои характеристики. При использовании же наследования объект определяет лишь те качества, которые делают его уникальным в рамках его класса. Более общие качества он может наследовать от родительского класса. Таким образом, механизм наследования позволяет объекту быть специфическим экземпляром более общего класса.

\centerline{\textbf{Примеры на C++:}}
1. \textbf{Инкапсуляция}.
Пример класса <<\textit{коробка}>>, инкапсулирующего данные и предоставляющего метод для вычисления объема.

\begin{lstlisting}[language=C++]
class Box { 
    int length;
    int width;
    int height; 
public:
    int volume() const {
        return length * width * height;
    }
}
\end{lstlisting}

2. \textbf{Наследование}.
Наследование свойств и поведения могут контролироваться с помощью квалификаторов доступа, задаваемых при наследовании: \textit{public, protected, private}.  В примере ниже класс C является наследником класса A.

\begin{lstlisting}[language=C++]
class A { 
public:
    virtual void f(int x) { 
        cout << "A::f" << '\n';
    }
};

class C: public A {
public:
    void f(int x) {
        cout << "C::f" << '\n';
    }
};
\end{lstlisting}

3. \textbf{Полиморфизм.}

\textbf{Статический полиморфизм} реализуется с помощью перегрузки функций и операций. Под перегрузкой функций в С++ понимается описание в одной области видимости нескольких функций с одним и тем же именем.
\begin{lstlisting}[language=C++]
void f(int x);
void f(double x);
\end{lstlisting}
\textbf{Динамический полиморфизм} реализуется с помощью механизма виртуальных методов.
Механизм виртуальных методов заключается в том, что результат вызова виртуального метода с использованием указателя или ссылки зависит не от того, на основе какого типа создан указатель, а от типа объекта, на который он указывает. Тип данных (класс), содержащий хотя бы одну виртуальную функцию, называется \textbf{полиморфным типом (классом)}, а объект этого типа – \textbf{полиморфным объектом}. Во всех наследниках виртуальная функция остается таковой.

В примере ниже используются описанные выше классы A и C.
\begin{lstlisting}[language=C++]
int main() { 
    A a1;
    C c1;
    C *pc = &c1;
    pc->f(1); // C::f
    A *pa = pc;
    pa->f(1); // C::f
    pc = (C*) &a1;
    pc->f(1); // A::f
    return 0;
}
\end{lstlisting}
\textbf{Чистая виртуальная функция} --- функция вида: \\
\textit{virtual <тип\_возвращаемого\_значения> имя\_функции (формальные\_параметры) = 0;}

Такая форма записи функции означает, что данная функция (точнее, метод класса) не имеет тела, описывающего ее алгоритм.

\textbf{Абстрактный класс} --- это класс, содержащий хотя бы одну чистую виртуальную функцию.

\textbf{Параметрический полиморфизм} позволяет применить один и тот же алгоритм к разным типам данных. При этом тип является параметром тела алгоритма. При обращении к функции-шаблону после имени функции в угловых скобках указываются фактические параметры шаблона -- имена реальных типов или значения объектов.
\begin{lstlisting}[language=C++]
template <class T> T max(T &x, T &y) {
    return x > y ? x : y; 
}
\end{lstlisting}

% -------- source --------
\bigbreak
[\cite[page 20-23]{gerbert}]